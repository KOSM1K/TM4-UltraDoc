\documentclass{article}
\usepackage[english, russian]{babel}
\usepackage{bm}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{scrextend}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{color}
\usepackage{colortbl}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{nccmath}
\usepackage{listings}
\usepackage[most]{tcolorbox}


\usepackage{authblk}
\title{Коллок 4}
\author[1]{Cosmo Chief}

\begin{document}
	\maketitle
	\tableofcontents
	\newpage
	\section{Formal languages}
	Формальный язык $\mathcal{L}$ - некторое подмножество всех слов из заданного алфавита $\Sigma$.\\
	\[
	\mathcal{L} \subseteq \Sigma^* \quad \quad \quad \Sigma^* = \sum_{k = 0}^{\infty} \Sigma^k
	\]
	
	\section{Operations on formal languages}
	\begin{itemize}
		\item
		Как множества:
		\begin{itemize}
		\item Объединение \(\mathcal{L}_1 \cup \mathcal{L}_2\)
		\item Пересечение \(\mathcal{L}_1 \cap \mathcal{L}_2\)
		\item Дополнение \(\neg \mathcal{L} = \Sigma^* \setminus \mathcal{L}\)
		\item ...?
		\end{itemize}
		\item
		Конкатенация\\
		\(\mathcal{L}_1 \cdot \mathcal{L}_2 = \{x + y \ | \ x \in \mathcal{L}_1, y \in \mathcal{L}_2\} \)
		\item
		Возведение в степень\\
		\(\mathcal{L}^k = \underbrace{\mathcal{L} \cdot ... \cdot \mathcal{L}}_{k \ \text{раз}} \)\\
		\(\mathcal{L}^0 = \{\epsilon\}\), $\epsilon$ = пустое слово
		\item
		Звезда Клини\\
		\(\mathcal{L}^* = \bigcup^{\infty}_{k = 0} \ L^k \)
	\end{itemize}
	
	\section{Regular languages}
	Множество регулярных языков задается так:\\
	\[
	REG = \bigcup^{\infty}_{k = 0} Reg_k = Reg_{\infty}\]
	\[
	Reg_{i+1} = Reg_{i} \cup \{\mathcal{L}_1 \cup \mathcal{L}_2, \mathcal{L}_1 \cdot \mathcal{L}_2, \mathcal{L}^{*}_{1} \ | \ \mathcal{L}_1, \mathcal{L}_2 \in Reg_i\}\]
	\[
	Reg_0 = \{\emptyset, \epsilon, \{c\} \ | \ c \in \Sigma\}\]\\
	Какой-то конкретный регулярный язык - регулярный язык, который может быть распознан каким-то конечным автоматом\\
	\textbf{Теорема Клини} утверждает, что класс регулярных языков совпадает с классом языков, распознаваемых конечными автоматами
	
	\section{Closure properties of regular languages}
	Множество регулярных языков замкнуто относительно
	\begin{itemize}
		\item Объединения
		\item Конкатенации
		\item Звезды Клини
	\end{itemize}
	Очевидно из определения:
	\[
	Reg_{i+1} = Reg_{i} \cup \{\mathcal{L}_1 \cup \mathcal{L}_2, \mathcal{L}_1 \cdot \mathcal{L}_2, \mathcal{L}^{*}_{1} \ | \ \mathcal{L}_1, \mathcal{L}_2 \in Reg_i\}\]\\
	Помимо этого, множество регулярных языков замкнуто относиттельно
	\begin{itemize}
		\item Пересечение \(\mathcal{L}_1 \cap \mathcal{L}_2\)
		\item Positive closure \(\mathcal{L}^+\)\\
		По сути это все та же звезда Клини, но язык сконкатенирован сам с собой \(k \geq 1\) раз. Тоесть\\
		\(\mathcal{L}^+ \subseteq \mathcal{L}^*\)
		\item Дополнение \(\neg \mathcal{L}\)
		\item Разность \(\mathcal{L}_1 \setminus \mathcal{L}_2\)
		\item Reversal \(\mathcal{L}^R\)\\
		По сути - берете конечный автомат, который выражает этот язык, и разворачиваете все ребра. (наверное надо будет еще добавить входную вершину, и из нее $\epsilon$-переходы в каждую, ранее терминальную вершину, а ранее входная вершина станет терминальной)\\
		Еще проще\\
		\(\forall w \in \mathcal{L} \ | \ w[::-1] \in \mathcal{L}^R \)\\
		Впрочем, скорее даже\\
		\(\{w[::-1]\} = \mathcal{L}^R \ | \ \forall w \in \mathcal{L} \)
		\item Гомомрфизм \(h(\mathcal{L})\)\\
		Сопоставляет на каждый символ из начального языка - строку\\
		Пусть есть $w \in \mathcal{L}$. $h(w) = h(a_1...a_n) = h(a_1) + ... + h(a_n)$\\
		$h(\mathcal{L}) = \{h(w) \ | \ \forall w \in \mathcal{L}\}$
		\item Обратный гомоморфизм \(h^{-1}(\mathcal{L})\)\\
		\(h^{-1}(h(\mathcal{L})) = \mathcal{L}\)
		\item Симметрическая разность \(\mathcal{L}_1 \bigtriangleup \mathcal{L}_2 = (\mathcal{L}_1 \setminus \mathcal{L}_2) \cup (\mathcal{L}_2 \setminus \mathcal{L}_1)\)
		\item Префикс (множество всех префиксов из регулярного языка)
		\item Субституция (Subtitution)\\
		Сопоставляет на каждый символ из начального языка - язык\\
		Пусть есть $w \in \mathcal{L}$. $f(w) = f(a_1...a_n) = f(a_1) \cdot ... \cdot f(a_n) = \mathcal{L}_{a_1} \cdot ... \cdot \mathcal{L}_{a_n}$\\
		Тоесть одной строке соответствует язык $\iff$ 1 и более строка.\\
		\(f(\mathcal{L}) = \bigcup f(w) \ | \ \forall w \in \mathcal{L}\)
		
	\end{itemize}
	
	\section{Pumping lemma}
	Если $\mathcal{L}$ - регулярный язык, то существует $n > 1$, зависящее только от $\mathcal{L}$, такое, что \\ \(\forall w \in \mathcal{L}, |w| > n \ | \ w = xyz\) так, что \\
	\(
	|y| > 0\\
	|xy| < n\\
	\forall k > 0 \ | \ xy^kz \in \mathcal{L}
	\)
	
	\section{Regular expressions}
	Регулярное выражение - выражение описывающее регулярный язык.\\ 
	Базис = $Reg_0$.\\
	Если $r_1$ и $r_2$, то следующие выражения также являются регулярными\\
	\begin{itemize}
		\item $r_1r_2$ - конкатенация
		\item $r^{*}_1$ - звезда Клини (повторения от 0 до $+\infty$)
		\item $r^{+}_1$ - Позитивное дополнение..? (повторения от 1 до $+\infty$)
		\item $r_1?$ - 0 или 1 повторение
		\item $\{expression\}\{n\}$ - повторение $expression$ ровно $n$ раз
		\item $\{expression\}\{min,\}$ - повторение $expression$ хотя бы $min$ раз
		\item $\{expression\}\{, max\}$ - повторение $expression$ менее $max$ раз
		\item $\{expression\}\{min, max\}$ - повторение $expression$ более $min$, менее $max$ раз
		\item $r_1 | r_2$ - $r_1$ или $r_2$
		\item $[a_1 ... a_n]$ - ровно одно $a_i$
		\item $()$ - для оперделения порядка применения операций
	\end{itemize}
	
	\section{Deterministic finite automata (DFA)}
	Детерменированный конечный автомат (ДКА) - это кортеж $(Q, \Sigma, \delta, q_0, F)$, где\\
	$Q$ - конечное множество состояний\\
	$\Sigma$ - алфавит\\
	$q_0\in Q$ - начальное состояние\\
	$F\subseteq Q$ множество принимающих состояний (терминалы)\\
	$\delta\colon Q\times\Sigma\to Q$ - функция перехода\\
	\noindent\\
	Автомат называется детерменированным так как из каждого состояния есть \textbf{ровно 1} переход для каждого символа\\
	Впрочем, некоторые авторы говорят что ДКА это автомат у которого из каждого состояния есть \textbf{не более 1} перехода для каждого символа (если "нужен" переход, которого нет, то автомиат останавливается)\\ 
	(Формально, детерменированный автомат, это автомат который всегда находится в ровно одном состоянии)\\
	
	\section{Non-deterministic finite automata (NFA)}
	Недетерменированный конечный автомат(НКА) - это кортеж $(Q, \Sigma, \delta, q_0, F)$, где\\
	$Q$ - конечное множество состояний\\
	$\Sigma$ - алфавит\\
	$q_0\in Q$ - начальное состояние\\
	$F\subseteq Q$ множество принимающих состояний (терминалы)\\
	$\delta\colon Q\times(\Sigma\cup\{\varepsilon\})\to 2^Q$ - функция перехода\\
	\textit{Обратите внимание, изменилось описание только функции перехода}
	\noindent\\
	
	Автомат называется недетерменированным, если для какого либо состояния для какого либо символа существует не ровно один переход, или если в автомате есть $\epsilon$-переход (переход не "достающий" символ из строки).\\
	(Такой автомат может находится в нескольких состояниях одновременно)
	
	\section{Rabin-Scott powerset construction}
	Конструкция Рабина-Скотта (subset construction) преобразует НКА в эквивалентный ДКА.\\
	\textit{Дальше идет упрощенное описание, потому что на вики какая то фигня происходит, это кажется слишком жестко и ничерта не понятно}\\
	\\
	Каждое состояние в результирующем ДКА - подмножество состояний исходного НКА.\\
	Каждое состояние ДКА имеющее хотя бы одно терминальное состояние из НКА - тоже терминальное.\\
	Пусть есть состояние $A$ из ДКА, и некоторый символ $x$, полученный из входной строки.
	Тогда переход из $A$ по $x$ будет в состояние $B$, такое что $B$ - множество всех состояний, достижимых из хотя бы одного состояния в $A$.\\
	Более формально:\\ 
	есть $A = \{a_1 ... a_n\}$ где $a_i$ - состояние исходного НКА,\\
	есть символ $x$, по которому мы вычисляем переход.\\
	Из исходного НКА мы можем найти $a_i \xrightarrow{x} \{b_{i1} ... b_{im}\} = b_i$ - множество состояний достижимых в НКА из $a_i$ при переходе по $x$.\\
	Тогда $B = \bigcup^{n}_{i=1} b_i$.\\
	И в результирующем ДКА $A \xrightarrow{x} B$
		
	\section{Epsilon-NFA}
	$\varepsilon$-НКА --- НКА, допускающий $\varepsilon$-переходы (переходы без чтения символа). Формально $\delta\colon Q\times(\Sigma\cup\{\varepsilon\})\to 2^Q$. Используется для удобства построения из регулярных выражений. Для $\varepsilon$-НКА вводится понятие $\varepsilon$-замыкания: 
	\[
	\varepsilon\text{-closure}(P) \;=\; \{\, q \mid \exists q_0\in P,\ q_0\stackrel{*\varepsilon}{\longrightarrow}q\}.
	\]
	Именно $\varepsilon$-замыкание начального состояния задаёт множество начальных состояний эквивалентного НКА без $\varepsilon$-переходов.
	
	\section{NFA construction from epsilon-NFA}
	Для удаления $\varepsilon$-переходов строится эквивалентный НКА без них. Каждый переход по символу $a$ из состояния $q$ в $\varepsilon$-НКА заменяется переходом из каждого состояния $p\in\varepsilon\text{-closure}(q)$ по символу $a$ в состояния из $\delta(p,a)$. Формально: 
	\[
	\delta'(q,a) = \bigcup_{p\in\varepsilon\text{-closure}(q)}\delta(p,a),
	\]
	при этом принимающие состояния 
	\[
	F' \;=\; \{\,q \mid \varepsilon\text{-closure}(q)\cap F\neq\emptyset\}.
	\]
	Полученный $\varepsilon$-свободный НКА распознаёт тот же язык, что и исходный.
	
	\section{Kleene’s theorem}
	\begin{itemize}
		\item \textit{Kleene’s theorem:} Регулярные языки эквивалентны регулярным выражениям; то есть для любого регулярного выражения существует ДКА (и НКА) с тем же языком, и наоборот, для любого ДКА есть регулярное выражение, задающее тот же язык.
		\item Это означает, что конструкции между регулярными выражениями и автоматами обратимы, то есть регулярные языки = языки ДКА/НКА.
	\end{itemize}
	
	\section{Kleene’s algorithm}
	Алгоритм Клини строит регулярное выражение по ДКА через последовательное исключение состояний. Определяется регулярное выражение $R_{ij}^{(k)}$ --- все слова, переводящие автомат из состояния $i$ в $j$, не используя промежуточные состояния с номерами более $k$. В базисе $k=0$ выражения соответствуют прямым переходам. Далее рекуррентно:
	\[
	R_{ij}^{(k)} = R_{ij}^{(k-1)} + R_{ik}^{(k-1)} \bigl(R_{kk}^{(k-1)}\bigr)^* R_{kj}^{(k-1)}.
	\]
	В конце $R_{s,t}^{(n)}$ между начальным и принимающими состояниями даёт искомое регулярное выражение.
	
	\section{Thompson’s construction}
	Построение Томпсона превращает регулярное выражение в эквивалентный НКА (обычно с $\varepsilon$-переходами). Каждая операция регулярного выражения соответствует конструкции автомата:
	\begin{itemize}
		\item Для символа $a$: автомат из нового начального состояния в новое конечное по переходу $a$.
		\item Для $r_1 + r_2$: создаётся новое начальное состояние с $\varepsilon$-переходами в начала автоматов для $r_1$ и $r_2$, а их концы соединяются с общим конечным состоянием через $\varepsilon$-переходы.
		\item Для конкатенации $r_1 r_2$: конец автомата $r_1$ соединяется с началом $r_2$ через $\varepsilon$-переход.
		\item Для $r^*$: от начала к концу добавляется $\varepsilon$-переход, а от конца к началу также $\varepsilon$-переход, обеспечивая цикличное повторение.
	\end{itemize}
	В результате получается НКА, принимающий тот же язык, что и исходное регулярное выражение.
	
	\section{Ordered arrangements}
	Упорядоченное размещение из $n$ элементов по $k$ (обозначается $A(n,k)$) --- выборка без повторений, упорядоченная. Количество:
	\[
	A(n,k) = n(n-1)\cdots(n-k+1) = \frac{n!}{(n-k)!}.
	\]
	Например, $A(5,3) = 5\times4\times3 = 60$. При $k=n$ это число перестановок $n!$.
	
	\section{Permutations and cyclic permutations}
	Перестановка из $n$ элементов --- это упорядоченное размещение всех элементов, число которых равно
	\[
	n! = 1\cdot2\cdots n.
	\]
	$k$-перестановка --- это частный случай упорядоченного размещения, равен $A(n,k)$. Циклическая перестановка (размещение по кругу) из $n$ элементов учитывает циклическую симметрию, и их число равно
	\[
	(n-1)!,
	\]
	так как можно зафиксировать один элемент и переставлять остальные $n-1$.
	
	\section{Unordered arrangements}
	Неупорядоченное размещение (сочетание) из $n$ по $k$ --- выборка $k$ элементов из $n$ без учёта порядка. Обозначается $\displaystyle \binom{n}{k}$. Количество:
	\[
	\binom{n}{k} = \frac{n!}{k!(n-k)!}.
	\]
	Свойства: $\binom{n}{0}=1$, $\binom{n}{n}=1$, $\binom{n}{k} = \binom{n}{n-k}$. Бином Ньютона:
	\[
	(x+y)^n = \sum_{k=0}^n \binom{n}{k} x^k y^{n-k}.
	\]
	
	\section{Multisets}
	Мультисет --- обобщение множества, допускающее повторения элементов. Мультисет задаётся так: у элементов типов $1,2,\dots,m$ есть количества $n_1,n_2,\dots,n_m$, общее число элементов $n=n_1+\dots +n_m$. Число перестановок такого мультисета:
	\[
	\frac{n!}{n_1!\,n_2!\cdots n_m!}.
	\]
	
	\section{Combinations of infinite multisets}
	Сочетание с повторениями (или сочетание из бесконечного мультисета) из $n$ типов элементов (каждого в неограниченном количестве) по $k$ элементов даёт формулу:
	\[
	\binom{n+k-1}{k}.
	\]
	Это соответствует количеству неубывающих последовательностей длины $k$ из $n$ типов или представлению $k$ в виде суммы $n$ неотрицательных слагаемых.
	
	\section{Multinomial theorem}
	Обобщённая биномная теорема:
	\[
	(x_1 + x_2 + \cdots + x_m)^n = \sum_{n_1+n_2+\cdots+n_m=n} \frac{n!}{n_1!n_2!\cdots n_m!} x_1^{n_1}x_2^{n_2}\cdots x_m^{n_m},
	\]
	где сумма берётся по неотрицательным целым $(n_1,\dots,n_m)$, сумма которых равна $n$. Коэффициенты $\displaystyle \frac{n!}{n_1!\cdots n_m!}$ называются мультиномиальными и равны числу способов разбить $n$ объектов на группы размеров $n_1,\dots,n_m$.
	
	\section{Compositions}
	Композиция целого $n$ --- упорядоченное разбиение $n = i_1 + i_2 + \cdots + i_k$ на $k$ положительных частей. Количество композиций $n$ в неограниченном числе частей равно $2^{n-1}$ (между $n$ единицами можно ставить либо разделитель, либо нет). Более детально: число композиций $n$ на $k$ частей равно $\displaystyle \binom{n-1}{k-1}$ (выбираем $k-1$ разбиений среди $n-1$ возможных).
	
	\section{Set partitions and Stirling numbers of the second kind}
	Партиция (разбиение) множества из $n$ элементов на $k$ блоков (неупорядоченных и непустых) считается числом Стирлинга второго рода $\displaystyle \bigl\{{n\atop k}\bigr\}$. Оно удовлетворяет рекурсии:
	\[
	\bigl\{{n\atop k}\bigr\} = k\bigl\{{n-1\atop k}\bigr\} + \bigl\{{n-1\atop k-1}\bigr\}, 
	\quad \bigl\{{n\atop 1}\bigr\}=1,\ \bigl\{{n\atop n}\bigr\}=1.
	\]
	Число Белла $B_n$ --- количество всех разбиений $n$-элементного множества (на любое число блоков):
	\[
	B_n = \sum_{k=0}^n \bigl\{{n\atop k}\bigr\}.
	\]
	
	\section{Bell numbers}
	Число Белла $B_n$ равно числу всех разбиений $n$-элементного множества. Генерирующая функция Белла:
	\[
	\sum_{n=0}^\infty B_n \frac{x^n}{n!} = \exp(e^x - 1).
	\]
	Некоторые значения: $B_0=1$, $B_1=1$, $B_2=2$, $B_3=5$, \dots
	
	\section{Integer partitions}
	Целочисленное разбиение $p(n)$ --- число способов представить $n$ как сумму неубывающих натуральных слагаемых (порядок неважен). Например, $p(4)=5$ для разбиений 
	\[
	4,\;3+1,\;2+2,\;2+1+1,\;1+1+1+1.
	\]
	Нет простых замкнутых формул, но есть рекуррентные соотношения и асимптотическая формула Харди--Рамануяна.
	
	\section{Principle of Inclusion-Exclusion}
	Для конечных множеств $A_1,\dots,A_m$ мощность объединения даётся формулой:
	\[
	\Bigl|\bigcup_{i=1}^m A_i\Bigr| = \sum_{i}|A_i| - \sum_{i<j}|A_i\cap A_j| + \sum_{i<j<k}|A_i\cap A_j\cap A_k| - \cdots + (-1)^{m-1}|A_1\cap \cdots \cap A_m|.
	\]
	Этот принцип позволяет учитывать пересечения при подсчёте, например, количество объектов, не обладающих ни одним из нежелательных свойств. В частности, число перестановок без фиксированных точек (derangements) можно получить:
	\[
	!n = n!\sum_{k=0}^n \frac{(-1)^k}{k!}.
	\]
	
	\section{Recurrence relations}
	Рекуррентное (или рекурсивное) соотношение --- это уравнение, задающее $a_n$ через предыдущие члены. Линейное однородное соотношение с постоянными коэффициентами имеет вид:
	\[
	a_n = c_1 a_{n-1} + c_2 a_{n-2} + \cdots + c_k a_{n-k}.
	\]
	Общее решение строится через корни характеристического многочлена
	\[
	\lambda^k - c_1 \lambda^{k-1} - \cdots - c_k = 0.
	\]
	Если корни $\lambda_1,\dots,\lambda_r$ различны, то $a_n = \sum_i \alpha_i \lambda_i^n$. Для кратных корней добавляются множители $n$, $n^2$ и т.д.
	
	\section{Solving recurrence relations using characteristic equations}
	Для решения однородных линейных рекурренций ищут корни характеристического уравнения 
	\[
	\lambda^k - c_1 \lambda^{k-1} - \cdots - c_k = 0.
	\]
	Если, например, корень $\lambda$ имеет кратность $m$, то вклад от него даётся $\alpha\,n^{m-1}\lambda^n$. Для неоднородных рекуррентов ищут сначала частное решение (например, подбирая вид, подобный неоднородной части), а затем добавляют общее решение однородного уравнения.
	
	\section{Generating functions}
	Порождающая функция последовательности $(a_n)$ --- формальный степенной ряд
	\[
	A(x) = \sum_{n=0}^\infty a_n x^n.
	\]
	Она кодирует последовательность и позволяет решить рекуррентные соотношения с помощью алгебраических манипуляций над рядами. Операции над порождающими функциями:
	\begin{itemize}
		\item Сумма рядов: $A(x)+B(x)=\sum (a_n+b_n)x^n$.
		\item Произведение рядов: $A(x)B(x)=\sum_{n\ge0}\Bigl(\sum_{k=0}^n a_k b_{n-k}\Bigr)x^n$ (свёртка коэффициентов).
		\item Стандартные ряды: $\frac{1}{1-x}=\sum_{n=0}^\infty x^n$, \;$\frac{1}{(1-x)^m}=\sum_{n=0}^\infty \binom{n+m-1}{m-1}x^n$.
	\end{itemize}
	
	\section{Solving linear recurrences using generating functions}
	Для линейного рекуррента составляют уравнение для $A(x)$, решают его и затем извлекают коэффициенты. Например, для Фибоначчи 
	\[
	a_n = a_{n-1} + a_{n-2},\quad a_0=0,\;a_1=1
	\]
	получаем 
	\[
	A(x) = xA(x) + x^2 A(x) + x,
	\]
	откуда 
	\[
	A(x)=\frac{x}{1-x-x^2}
	\]
	и извлекается формула 
	\[
	a_n = \frac{1}{\sqrt5}\Bigl(\bigl(\tfrac{1+\sqrt5}2\bigr)^n - \bigl(\tfrac{1-\sqrt5}2\bigr)^n\Bigr).
	\]
	
	\section{Solving combinatorial problems using generating functions}
	Для комбинаторных классов строят порождающие функции по правилам: правило суммы соответствует объединению классов (сумма ГФ), правило произведения --- декартово произведение (произведение ГФ). Например, если имеется $m$ типов букв, каждая может повторяться любое число раз, то полная ГФ равна 
	\[
	(1+x+x^2+\dots)^m = \frac{1}{(1-x)^m},
	\]
	и коэффициент при $x^n$ равен 
	\[
	\binom{n+m-1}{m-1}
	\]
	(числу слов длины $n$).
	
	\section{Operators and annihilators}
	Линейный разностный оператор $E$ действует как $E(a_n)=a_{n+1}$. Оператор $\Delta = E-1$ даёт разность $\Delta(a_n)=a_{n+1}-a_n$. Аннигилятором называется такой оператор, который обращает последовательность в нулевую. Например, оператор $E-1$ аннигилирует константу (так как $a_{n+1}-a_n=0$), оператор $E-2$ аннигилирует геометрическую прогрессию $2^n$ ($2a_{n} - a_{n+1}=0$). Идея: найти оператор, аннигилирующий неоднородную часть $f(n)$, и применить его к исходному уравнению, чтобы получить однородное соотношение.
	
	\section{Solving linear recurrences using annihilators}
	Если дано рекуррентное соотношение 
	\[
	a_n + c_1 a_{n-1} + \cdots + c_k a_{n-k} = f(n),
	\]
	ищут оператор $P(E)$ такой, что $P(E)f(n)=0$. Умножая исходное уравнение оператором $P(E)$, получают новое однородное соотношение 
	\[
	P(E)\bigl(E^k + \cdots + c_k\bigr)=0
	\]
	для $a_n$, решают его, затем отбрасывают лишние решения, чтобы учесть начальные условия исходного уравнения.
	
	\section{Catalan numbers}
	Числа Каталана $\{C_n\}$ можно определить, например, как количество правильных скобочных последовательностей длины $2n$ или число способов разбить $(n+2)$-угольник на треугольники. Формула:
	\[
	C_n = \frac{1}{n+1}\binom{2n}{n}.
	\]
	Рекуррентно: $C_0=1$, 
	\[
	C_{n+1} = \sum_{i=0}^n C_i\,C_{n-i}.
	\]
	Генерирующая функция $C(x)=\sum_{n\ge0}C_n x^n$ удовлетворяет уравнению 
	\[
	C(x)=1 + x\,C(x)^2,
	\]
	что даёт замкнутую форму 
	\[
	C_n = \frac{1}{n+1}\binom{2n}{n}.
	\]
	
	\section{Generalized binomial theorem}
	Для любого действительного (или комплексного) $r$ справедливо:
	\[
	(1+x)^r = \sum_{k=0}^\infty \binom{r}{k} x^k, \quad \text{где } \binom{r}{k} = \frac{r(r-1)\cdots(r-k+1)}{k!}.
	\]
	Ряд бесконечен и сходится при $|x|<1$. Для натурального $r$ ряд конечен и совпадает с обычной биномной теоремой.
	
	\section{Gamma function}
	Гамма-функция $\Gamma(x)$ продолжает факториал на вещественные и комплексные значения:
	\[
	\Gamma(x) = \int_0^\infty t^{x-1} e^{-t}\,dt,
	\]
	при этом $\Gamma(n)=(n-1)!$ для натуральных $n$. Рекуррентно: $\Gamma(x+1)=x\,\Gamma(x)$. Гамма-функция играет роль обобщённого факториала во многих формулах.
	
	\section{Divide-and-Conquer algorithms analysis using recursion trees}
	Метод рекурсивных деревьев используется для оценки сложности рекурсивных алгоритмов вида 
	\[
	T(n)=a\,T\Bigl(\frac{n}{b}\Bigr) + f(n).
	\]
	Строят дерево рекурсии: на $i$-м уровне $a^i$ узлов, каждый параметром $n/b^i$ и затратами $f(n/b^i)$. Суммарное время 
	\[
	T(n)=\sum_{i=0}^{\log_b n} a^i\,f\Bigl(\frac{n}{b^i}\Bigr).
	\]
	Сравнивая вклад каждого уровня, можно определить асимптотику $T(n)$.
	
	\section{Master theorem}
	Рассматривается рекуррент
	\[
	T(n)=a\,T\Bigl(\frac{n}{b}\Bigr) + f(n),
	\]
	где $a\ge1$, $b>1$ и $f(n)$ положительная функция. Тогда:
	\begin{itemize}
		\item Если $f(n) = O\bigl(n^{\log_b a - \varepsilon}\bigr)$ для некоторого $\varepsilon>0$, то $T(n) = \Theta\bigl(n^{\log_b a}\bigr)$.
		\item Если $f(n) = \Theta\bigl(n^{\log_b a}\log^k n\bigr)$ для некоторого $k\ge0$, то $T(n) = \Theta\bigl(n^{\log_b a}\log^{\,k+1}n\bigr)$.
		\item Если $f(n) = \Omega\bigl(n^{\log_b a + \varepsilon}\bigr)$ для некоторого $\varepsilon>0$ и при этом $a\,f(n/b) \le c\,f(n)$ для некоторого $c<1$ при достаточно больших $n$, то $T(n) = \Theta(f(n))$.
	\end{itemize}
	
	\section{Akra–Bazzi method}
	Обобщение Мастер-теоремы для более сложных рекуррент:
	\[
	T(x) = \sum_{i=1}^k a_i\,T(b_i x + g_i(x)) + f(x),
	\]
	где $a_i>0$, $0<b_i<1$, $g_i(x)=O\bigl(x/\log^2 x\bigr)$, $f(x)$ неотрицательна. Сначала решают уравнение 
	\[
	\sum_{i=1}^k a_i\,b_i^p = 1
	\]
	относительно $p>0$. Тогда оценка даётся формулой
	\[
	T(x) = \Theta\Bigl(x^p\Bigl(1 + \int_1^x \frac{f(u)}{u^{\,p+1}}\,du\Bigr)\Bigr).
	\]
	Этот метод позволяет получать асимптотику рекуррентных соотношений, где аргументы рекурсии уменьшаются неравномерно.
	
	
	
\end{document}
